/**
 * Vue composable for integrating with Crux Core
 *
 * This composable provides the bridge between the Vue UI shell and the
 * Crux Core (Rust compiled to WASM). It handles:
 * - Sending events to the core
 * - Processing effects from the core
 * - Providing reactive access to the view model
 *
 * The generated types from shared_types provide serialization/deserialization
 * for bincode FFI communication with the WASM module.
 *
 * Build the WASM module with:
 *   cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
 *
 * Generate TypeScript types with:
 *   export PATH="$HOME/.local/share/pnpm:$PATH" && cargo build -p shared_types
 */

import { ref, reactive, readonly, type DeepReadonly } from 'vue'
import { useCentrifuge } from './useCentrifugo'
import { CentrifugeSubscriptionType } from '../enums/centrifuge-subscription-type.enum'

// Re-export generated types from shared_types for use in Vue components
// These types are generated by TypeGen from the Crux Core Rust types
export type {
  SystemInfo,
  NetworkStatus,
  OnlineStatus,
  FactoryReset,
  UpdateValidationStatus,
  Timeouts,
  HealthcheckInfo,
  Event,
  Effect,
  Model as CoreViewModel,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import event constructors for sending events to the core
import {
  EventVariantInitialize,
  EventVariantLogin,
  EventVariantLogout,
  EventVariantSetPassword,
  EventVariantUpdatePassword,
  EventVariantCheckRequiresPasswordSet,
  EventVariantReboot,
  EventVariantFactoryResetRequest,
  EventVariantReloadNetwork,
  EventVariantSetNetworkConfig,
  EventVariantLoadUpdate,
  EventVariantRunUpdate,
  EventVariantSubscribeToChannels,
  EventVariantUnsubscribeFromChannels,
  EventVariantClearError,
  EventVariantClearSuccess,
  type Event,
  Model as GeneratedViewModel,
  Request as CruxRequest,
  Effect as EffectClass,
  EffectVariantRender,
  EffectVariantHttp,
  EffectVariantCentrifugo,
  FactoryResetStatusVariantunknown,
  FactoryResetStatusVariantmode_supported,
  FactoryResetStatusVariantmode_unsupported,
  FactoryResetStatusVariantbackup_restore_error,
  FactoryResetStatusVariantconfiguration_error,
  HttpResponse as CoreHttpResponse,
  HttpHeader as CoreHttpHeader,
  HttpResultVariantOk,
  HttpResultVariantErr,
  HttpErrorVariantIo,
  // Centrifugo types
  CentrifugoOperationVariantConnect,
  CentrifugoOperationVariantDisconnect,
  CentrifugoOperationVariantSubscribe,
  CentrifugoOperationVariantUnsubscribe,
  CentrifugoOperationVariantSubscribeAll,
  CentrifugoOperationVariantUnsubscribeAll,
  CentrifugoOperationVariantHistory,
  CentrifugoOutputVariantConnected,
  CentrifugoOutputVariantDisconnected,
  CentrifugoOutputVariantSubscribed,
  CentrifugoOutputVariantUnsubscribed,
  CentrifugoOutputVariantMessage,
  CentrifugoOutputVariantHistoryResult,
  CentrifugoOutputVariantError,
} from '../../../shared_types/generated/typescript/types/shared_types'

// Import serialization utilities
import { BincodeSerializer } from '../../../shared_types/generated/typescript/bincode/mod'
import { BincodeDeserializer } from '../../../shared_types/generated/typescript/bincode/mod'

// Helper to convert FactoryResetStatus class variant to string literal
type FactoryResetStatusString = 'unknown' | 'mode_supported' | 'mode_unsupported' | 'backup_restore_error' | 'configuration_error'

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function factoryResetStatusToString(status: any): FactoryResetStatusString {
  if (status instanceof FactoryResetStatusVariantunknown) return 'unknown'
  if (status instanceof FactoryResetStatusVariantmode_supported) return 'mode_supported'
  if (status instanceof FactoryResetStatusVariantmode_unsupported) return 'mode_unsupported'
  if (status instanceof FactoryResetStatusVariantbackup_restore_error) return 'backup_restore_error'
  if (status instanceof FactoryResetStatusVariantconfiguration_error) return 'configuration_error'
  return 'unknown'
}

// Simple ViewModel interface for Vue reactivity (mirrors CoreViewModel but with JS types)
export interface ViewModel {
  system_info: {
    os: { name: string; version: string }
    azure_sdk_version: string
    omnect_device_service_version: string
    boot_time: string | null
  } | null
  network_status: {
    network_status: Array<{
      ipv4: {
        addrs: Array<{ addr: string; dhcp: boolean; prefix_len: number }>
        dns: string[]
        gateways: string[]
      }
      mac: string
      name: string
      online: boolean
    }>
  } | null
  online_status: { iothub: boolean } | null
  factory_reset: {
    keys: string[]
    result: {
      status: 'unknown' | 'mode_supported' | 'mode_unsupported' | 'backup_restore_error' | 'configuration_error'
      context: string | null
      error: string
      paths: string[]
    }
  } | null
  update_validation_status: { status: string } | null
  timeouts: { wait_online_timeout: { nanos: number; secs: bigint } } | null
  healthcheck: {
    version_info: { version: string; git_sha: string }
    update_validation_status: { status: string }
  } | null
  is_authenticated: boolean
  requires_password_set: boolean
  is_loading: boolean
  error_message: string | null
  success_message: string | null
  is_connected: boolean
}

// Singleton state
const viewModel = reactive<ViewModel>({
  system_info: null,
  network_status: null,
  online_status: null,
  factory_reset: null,
  update_validation_status: null,
  timeouts: null,
  healthcheck: null,
  is_authenticated: false,
  requires_password_set: false,
  is_loading: false,
  error_message: null,
  success_message: null,
  is_connected: false,
})

const isInitialized = ref(false)

// WASM module reference (will be set when WASM is loaded)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let wasmModule: any = null

// Centrifugo instance for WebSocket operations
const centrifugoInstance = useCentrifuge()

// Map of active subscription request IDs waiting for messages
const activeSubscriptions = new Map<string, number>()

/**
 * Serialize an Event to bincode bytes
 */
function serializeEvent(event: Event): Uint8Array {
  const serializer = new BincodeSerializer()
  event.serialize(serializer)
  return serializer.getBytes()
}

/**
 * Execute an HTTP request and return the result to the Core
 *
 * This is the shell's implementation of the HTTP capability.
 * It converts the Core's HttpRequest into a fetch() call,
 * then serializes the result back for the Core to process.
 */
async function executeHttpRequest(
  requestId: number,
  httpRequest: { method: string; url: string; headers: Array<{ name: string; value: string }>; body: Uint8Array }
): Promise<void> {
  if (!wasmModule) {
    console.warn('WASM module not loaded, cannot execute HTTP request')
    return
  }

  console.log(`[HTTP Effect ${requestId}] ${httpRequest.method} ${httpRequest.url}`)
  console.log(`[HTTP Effect ${requestId}] Headers:`, httpRequest.headers)
  if (httpRequest.body.length > 0) {
    try {
      const bodyText = new TextDecoder().decode(httpRequest.body)
      console.log(`[HTTP Effect ${requestId}] Body:`, bodyText)
    } catch {
      console.log(`[HTTP Effect ${requestId}] Body: <binary ${httpRequest.body.length} bytes>`)
    }
  }

  try {
    // Convert Core headers to fetch headers
    const headers = new Headers()
    for (const header of httpRequest.headers) {
      headers.append(header.name, header.value)
    }

    // Build fetch options
    const fetchOptions: RequestInit = {
      method: httpRequest.method,
      headers,
    }

    // Add body for non-GET/HEAD requests
    if (httpRequest.method !== 'GET' && httpRequest.method !== 'HEAD' && httpRequest.body.length > 0) {
      fetchOptions.body = httpRequest.body
    }

    // Execute the fetch request
    console.log(`[HTTP Effect ${requestId}] Executing fetch...`)
    const response = await fetch(httpRequest.url, fetchOptions)
    console.log(`[HTTP Effect ${requestId}] Response: ${response.status} ${response.statusText}`)

    // Convert response headers
    const responseHeaders: Array<CoreHttpHeader> = []
    response.headers.forEach((value, name) => {
      responseHeaders.push(new CoreHttpHeader(name, value))
    })

    // Get response body as bytes
    const bodyBuffer = await response.arrayBuffer()
    const bodyBytes = new Uint8Array(bodyBuffer)
    console.log(`[HTTP Effect ${requestId}] Response body: ${bodyBytes.length} bytes`)

    // Create HttpResponse
    const httpResponse = new CoreHttpResponse(response.status, responseHeaders, bodyBytes)

    // Create success result
    const result = new HttpResultVariantOk(httpResponse)

    // Serialize the result
    const serializer = new BincodeSerializer()
    result.serialize(serializer)
    const resultBytes = serializer.getBytes()
    console.log(`[HTTP Effect ${requestId}] Sending result back to Core (${resultBytes.length} bytes)`)

    // Send result back to Core
    const newEffectsBytes = wasmModule.handle_response(requestId, resultBytes) as Uint8Array
    console.log(`[HTTP Effect ${requestId}] Core returned ${newEffectsBytes.length} bytes of new effects`)

    // Process any new effects that result from the response
    if (newEffectsBytes.length > 0) {
      await processEffects(newEffectsBytes)
    }
  } catch (error) {
    // Create error result
    const errorMessage = error instanceof Error ? error.message : String(error)
    console.error(`[HTTP Effect ${requestId}] Error:`, errorMessage)
    const httpError = new HttpErrorVariantIo(errorMessage)
    const result = new HttpResultVariantErr(httpError)

    // Serialize the error result
    const serializer = new BincodeSerializer()
    result.serialize(serializer)
    const resultBytes = serializer.getBytes()

    // Send error back to Core
    const newEffectsBytes = wasmModule.handle_response(requestId, resultBytes) as Uint8Array
    console.log(`[HTTP Effect ${requestId}] Core returned ${newEffectsBytes.length} bytes after error`)

    // Process any new effects
    if (newEffectsBytes.length > 0) {
      await processEffects(newEffectsBytes)
    }
  }
}

/**
 * Send a Centrifugo output result back to the Core
 */
async function sendCentrifugoResult(
  requestId: number,
  output:
    | CentrifugoOutputVariantConnected
    | CentrifugoOutputVariantDisconnected
    | CentrifugoOutputVariantSubscribed
    | CentrifugoOutputVariantUnsubscribed
    | CentrifugoOutputVariantMessage
    | CentrifugoOutputVariantHistoryResult
    | CentrifugoOutputVariantError
): Promise<void> {
  if (!wasmModule) {
    console.warn('WASM module not loaded, cannot send Centrifugo result')
    return
  }

  const serializer = new BincodeSerializer()
  output.serialize(serializer)
  const resultBytes = serializer.getBytes()

  console.log(`[Centrifugo Effect ${requestId}] Sending result back to Core (${resultBytes.length} bytes)`)

  const newEffectsBytes = wasmModule.handle_response(requestId, resultBytes) as Uint8Array

  if (newEffectsBytes.length > 0) {
    await processEffects(newEffectsBytes)
  }
}

/**
 * Execute a Centrifugo operation and return the result to the Core
 *
 * This is the shell's implementation of the Centrifugo capability.
 * It uses the existing useCentrifugo composable to interact with the
 * Centrifugo WebSocket server.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function executeCentrifugoOperation(requestId: number, operation: any): Promise<void> {
  console.log(`[Centrifugo Effect ${requestId}]`, operation)

  try {
    if (operation instanceof CentrifugoOperationVariantConnect) {
      // Connect to Centrifugo
      centrifugoInstance.initializeCentrifuge()

      // Wait for connection
      centrifugoInstance.onConnected(() => {
        console.log(`[Centrifugo Effect ${requestId}] Connected`)
        sendCentrifugoResult(requestId, new CentrifugoOutputVariantConnected())
      })
    } else if (operation instanceof CentrifugoOperationVariantDisconnect) {
      // Disconnect from Centrifugo
      centrifugoInstance.disconnect()
      console.log(`[Centrifugo Effect ${requestId}] Disconnected`)
      await sendCentrifugoResult(requestId, new CentrifugoOutputVariantDisconnected())
    } else if (operation instanceof CentrifugoOperationVariantSubscribe) {
      // Subscribe to a specific channel
      const channel = operation.channel as string
      console.log(`[Centrifugo Effect ${requestId}] Subscribing to ${channel}`)

      // Store the request ID for this subscription so we can send messages back
      activeSubscriptions.set(channel, requestId)

      // Subscribe and forward messages to Core
      await centrifugoInstance.subscribe((data: unknown) => {
        const jsonData = JSON.stringify(data)
        console.log(`[Centrifugo Message] ${channel}:`, jsonData)

        // Send message to Core (use same request ID)
        const msgRequestId = activeSubscriptions.get(channel) ?? requestId
        sendCentrifugoResult(msgRequestId, new CentrifugoOutputVariantMessage(channel, jsonData))
      }, channel as CentrifugeSubscriptionType)

      // Notify subscription confirmed
      await sendCentrifugoResult(requestId, new CentrifugoOutputVariantSubscribed(channel))
    } else if (operation instanceof CentrifugoOperationVariantUnsubscribe) {
      // Unsubscribe from a specific channel
      const channel = operation.channel as string
      centrifugoInstance.unsubscribe(channel)
      activeSubscriptions.delete(channel)
      console.log(`[Centrifugo Effect ${requestId}] Unsubscribed from ${channel}`)
      await sendCentrifugoResult(requestId, new CentrifugoOutputVariantUnsubscribed(channel))
    } else if (operation instanceof CentrifugoOperationVariantSubscribeAll) {
      // Subscribe to all known channels
      const channels = Object.values(CentrifugeSubscriptionType)
      console.log(`[Centrifugo Effect ${requestId}] Subscribing to all channels:`, channels)

      // Initialize Centrifugo first if needed
      centrifugoInstance.initializeCentrifuge()

      // Wait for connection then subscribe
      centrifugoInstance.onConnected(async () => {
        console.log(`[Centrifugo Effect ${requestId}] Connected, subscribing to channels`)

        for (const channel of channels) {
          // Store request ID for this channel
          activeSubscriptions.set(channel, requestId)

          // Subscribe with message forwarding
          await centrifugoInstance.subscribe((data: unknown) => {
            const jsonData = JSON.stringify(data)
            console.log(`[Centrifugo Message] ${channel}:`, jsonData)
            sendCentrifugoResult(requestId, new CentrifugoOutputVariantMessage(channel, jsonData))
          }, channel)

          // Also get history for initial data
          await centrifugoInstance.history((data: unknown) => {
            const jsonData = JSON.stringify(data)
            console.log(`[Centrifugo History] ${channel}:`, jsonData)
            sendCentrifugoResult(
              requestId,
              new CentrifugoOutputVariantHistoryResult(channel, jsonData)
            )
          }, channel)
        }

        // Notify all subscriptions complete
        await sendCentrifugoResult(requestId, new CentrifugoOutputVariantConnected())
      })
    } else if (operation instanceof CentrifugoOperationVariantUnsubscribeAll) {
      // Unsubscribe from all channels
      centrifugoInstance.unsubscribeAll()
      activeSubscriptions.clear()
      console.log(`[Centrifugo Effect ${requestId}] Unsubscribed from all channels`)
      await sendCentrifugoResult(requestId, new CentrifugoOutputVariantDisconnected())
    } else if (operation instanceof CentrifugoOperationVariantHistory) {
      // Get history for a specific channel
      const channel = operation.channel as string
      console.log(`[Centrifugo Effect ${requestId}] Getting history for ${channel}`)

      await centrifugoInstance.history((data: unknown) => {
        const jsonData = data ? JSON.stringify(data) : null
        console.log(`[Centrifugo History] ${channel}:`, jsonData)
        sendCentrifugoResult(requestId, new CentrifugoOutputVariantHistoryResult(channel, jsonData))
      }, channel)
    } else {
      console.error(`[Centrifugo Effect ${requestId}] Unknown operation:`, operation)
      await sendCentrifugoResult(
        requestId,
        new CentrifugoOutputVariantError('Unknown Centrifugo operation')
      )
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    console.error(`[Centrifugo Effect ${requestId}] Error:`, errorMessage)
    await sendCentrifugoResult(requestId, new CentrifugoOutputVariantError(errorMessage))
  }
}

/**
 * Process effects from the Crux Core
 *
 * When the core returns effects, this function handles them:
 * - Render: Update the view model by fetching it from the core
 * - Http: Make HTTP requests and send responses back to core
 * - Centrifugo: Handle WebSocket subscriptions
 */
async function processEffects(effectsBytes: Uint8Array): Promise<void> {
  if (!wasmModule) {
    console.warn('WASM module not loaded, cannot process effects')
    return
  }

  // Deserialize effects from bincode (array of Request objects)
  const deserializer = new BincodeDeserializer(effectsBytes)
  const numRequests = deserializer.deserializeLen()

  for (let i = 0; i < numRequests; i++) {
    const request = CruxRequest.deserialize(deserializer)
    const effect = request.effect

    if (effect instanceof EffectVariantRender) {
      // Render effect: Update the view model from core
      updateViewModelFromCore()
    } else if (effect instanceof EffectVariantHttp) {
      // HTTP effect: Execute HTTP request and send response back to core
      const httpRequest = effect.value
      console.log(`HTTP ${httpRequest.method} ${httpRequest.url}`)

      // Execute the request asynchronously (don't await to allow parallel processing)
      executeHttpRequest(request.id, {
        method: httpRequest.method,
        url: httpRequest.url,
        headers: httpRequest.headers.map(h => ({ name: h.name, value: h.value })),
        body: httpRequest.body,
      }).catch((error) => {
        console.error('Failed to execute HTTP request:', error)
      })
    } else if (effect instanceof EffectVariantCentrifugo) {
      // Centrifugo effect: Handle WebSocket subscription
      const centrifugoOperation = effect.value
      console.log(`Centrifugo operation:`, centrifugoOperation)

      // Execute the operation asynchronously
      executeCentrifugoOperation(request.id, centrifugoOperation).catch((error) => {
        console.error('Failed to execute Centrifugo operation:', error)
      })
    } else {
      console.warn('Unknown effect type:', effect)
    }
  }
}

/**
 * Update the reactive view model from the Crux Core
 */
function updateViewModelFromCore(): void {
  if (!wasmModule) {
    return
  }

  try {
    // Get serialized view model from WASM
    const viewModelBytes = wasmModule.view() as Uint8Array

    // Deserialize it using the generated ViewModel class
    const deserializer = new BincodeDeserializer(viewModelBytes)
    const coreViewModel = GeneratedViewModel.deserialize(deserializer)

    // Update the reactive view model with deserialized data
    // system_info
    if (coreViewModel.system_info) {
      viewModel.system_info = {
        os: {
          name: coreViewModel.system_info.os.name,
          version: coreViewModel.system_info.os.version,
        },
        azure_sdk_version: coreViewModel.system_info.azure_sdk_version,
        omnect_device_service_version: coreViewModel.system_info.omnect_device_service_version,
        boot_time: coreViewModel.system_info.boot_time || null,
      }
    } else {
      viewModel.system_info = null
    }

    // network_status
    if (coreViewModel.network_status) {
      viewModel.network_status = {
        network_status: coreViewModel.network_status.network_status.map((net) => ({
          ipv4: {
            addrs: net.ipv4.addrs.map((addr) => ({
              addr: addr.addr,
              dhcp: addr.dhcp,
              prefix_len: addr.prefix_len,
            })),
            dns: net.ipv4.dns,
            gateways: net.ipv4.gateways,
          },
          mac: net.mac,
          name: net.name,
          online: net.online,
        })),
      }
    } else {
      viewModel.network_status = null
    }

    // online_status
    viewModel.online_status = coreViewModel.online_status
      ? { iothub: coreViewModel.online_status.iothub }
      : null

    // factory_reset - convert status variant to string literal
    viewModel.factory_reset = coreViewModel.factory_reset
      ? {
          keys: coreViewModel.factory_reset.keys,
          result: {
            status: factoryResetStatusToString(coreViewModel.factory_reset.result.status),
            context: coreViewModel.factory_reset.result.context || null,
            error: coreViewModel.factory_reset.result.error,
            paths: coreViewModel.factory_reset.result.paths,
          },
        }
      : null

    // update_validation_status
    viewModel.update_validation_status = coreViewModel.update_validation_status
      ? { status: coreViewModel.update_validation_status.status }
      : null

    // timeouts
    viewModel.timeouts = coreViewModel.timeouts
      ? {
          wait_online_timeout: {
            nanos: coreViewModel.timeouts.wait_online_timeout.nanos,
            secs: coreViewModel.timeouts.wait_online_timeout.secs,
          },
        }
      : null

    // healthcheck
    viewModel.healthcheck = coreViewModel.healthcheck
      ? {
          version_info: {
            version: coreViewModel.healthcheck.version_info.version,
            git_sha: coreViewModel.healthcheck.version_info.git_sha,
          },
          update_validation_status: {
            status: coreViewModel.healthcheck.update_validation_status.status,
          },
        }
      : null

    // Boolean and string fields
    viewModel.is_authenticated = coreViewModel.is_authenticated
    viewModel.requires_password_set = coreViewModel.requires_password_set
    viewModel.is_loading = coreViewModel.is_loading
    viewModel.error_message = coreViewModel.error_message || null
    viewModel.success_message = coreViewModel.success_message || null
    viewModel.is_connected = coreViewModel.is_connected
  } catch (error) {
    console.error('Failed to update view model from core:', error)
  }
}

/**
 * Send an event to the Crux Core
 *
 * This serializes the event, sends it to the WASM core, and processes
 * any resulting effects.
 */
async function sendEventToCore(event: Event): Promise<void> {
  if (!isInitialized.value || !wasmModule) {
    console.warn('Core not initialized, cannot send event')
    return
  }

  try {
    // Serialize the event using bincode
    const eventBytes = serializeEvent(event)

    // Call process_event() on the WASM module
    const effectsBytes = wasmModule.process_event(eventBytes) as Uint8Array

    // Process the resulting effects
    await processEffects(effectsBytes)
  } catch (error) {
    console.error('Failed to send event to core:', error)
  }
}

/**
 * Initialize the Crux Core
 *
 * This loads the WASM module and sets up the core state.
 */
async function initializeCore(): Promise<void> {
  if (isInitialized.value) {
    return
  }

  console.log('Initializing Crux Core...')

  try {
    // Dynamically import the WASM module
    // This will be available after running:
    // cd src/app && wasm-pack build --target web --out-dir ../ui/src/core/pkg
    const wasm = await import('../core/pkg/omnect_ui_core')
    await wasm.default()
    wasmModule = wasm

    isInitialized.value = true
    console.log('Crux Core WASM module loaded successfully')

    // Send initial event
    await sendEventToCore(new EventVariantInitialize())
  } catch (error) {
    console.error('Failed to load Crux Core WASM module:', error)
    console.log('Running in fallback mode without WASM')
    isInitialized.value = true
  }
}

/**
 * Vue composable for Crux Core integration
 *
 * Usage:
 * ```typescript
 * const { viewModel, sendEvent, initialize } = useCore()
 *
 * onMounted(() => {
 *   initialize()
 * })
 *
 * // Send events using event constructors
 * sendEvent(new EventVariantLogin('user', 'pass'))
 *
 * // Or use convenience methods
 * login('user', 'pass')
 *
 * // Access view model
 * const isLoading = computed(() => viewModel.is_loading)
 * ```
 */
export function useCore() {
  return {
    // Provide readonly access to the view model
    viewModel: readonly(viewModel) as DeepReadonly<ViewModel>,

    // Event sending (using Event type from shared_types)
    sendEvent: sendEventToCore,

    // Initialization
    initialize: initializeCore,
    isInitialized: readonly(isInitialized),

    // Convenience methods for common events
    login: (username: string, password: string) =>
      sendEventToCore(new EventVariantLogin(username, password)),
    logout: () => sendEventToCore(new EventVariantLogout()),
    setPassword: (password: string) => sendEventToCore(new EventVariantSetPassword(password)),
    updatePassword: (current: string, newPassword: string) =>
      sendEventToCore(new EventVariantUpdatePassword(current, newPassword)),
    checkRequiresPasswordSet: () => sendEventToCore(new EventVariantCheckRequiresPasswordSet()),
    reboot: () => sendEventToCore(new EventVariantReboot()),
    factoryReset: (mode: string, preserve: string[]) =>
      sendEventToCore(new EventVariantFactoryResetRequest(mode, preserve)),
    reloadNetwork: () => sendEventToCore(new EventVariantReloadNetwork()),
    setNetworkConfig: (config: string) =>
      sendEventToCore(new EventVariantSetNetworkConfig(config)),
    loadUpdate: (filePath: string) => sendEventToCore(new EventVariantLoadUpdate(filePath)),
    runUpdate: (validateIothub: boolean) =>
      sendEventToCore(new EventVariantRunUpdate(validateIothub)),
    subscribeToChannels: () => sendEventToCore(new EventVariantSubscribeToChannels()),
    unsubscribeFromChannels: () => sendEventToCore(new EventVariantUnsubscribeFromChannels()),
    clearError: () => sendEventToCore(new EventVariantClearError()),
    clearSuccess: () => sendEventToCore(new EventVariantClearSuccess()),
  }
}
